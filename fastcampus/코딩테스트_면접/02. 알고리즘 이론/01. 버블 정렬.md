#### 1. 버블 정렬이란?

- 두 인접한 데이터를 비교해서, 앞에 있는 데이터가 뒤에 있는 데이터보다 크면, 자리를 바꾸는 정렬 알고리즘



#### 2. 어떻게 코드로 만들까?



1. 데이터가 두 개 있을 때 - 조건 체크 1 번 * 턴 1번

0번과 1번 비교해서 1번이 0보다 작으면 바꿔준다.

2. 데이터가 세 개 있을 때 - 조건 체크 2번 * 턴 2번

0번 1번 비교, 1번이 0보다 작으면 바꿔주기

1번 2번 비교, 2번이 1보다 작으면 바꿔주기

0번 1번 비교

1번 2번 비교

3. 데이터가 네 개 있을 때 -조건 체크 3번 * 턴 3번

0과 1 비교

1과 2 비교

2와 3 비교

0과 1 비교

1과 2 비교

2와 3 비교

0과 1 비교

1과 2 비교

2와 3 비교



```python
for index in range(데이터길이 - 1): # 턴
	for index2 in range(데이터길이 - 1): # 조건체크
		if 앞데이터 > 뒤데이터:
		 	swap(앞데이터, 뒤데이터)
```

값이 제일 큰 요소가 맨 뒤에 들어간다. 

그러면 한 번 정렬해서 제일 큰 요소가 맨뒤에 갔다면, 제일 큰 요소와 앞의 요소를 비교할 필요가 없다. 어차피 바꾸지 않을 테니.

그렇게 되면 조건 체크가 턴을 할 때마다 하나씩 준다.

```python
for index in range(데이터길이 - 1): # 턴
	for index2 in range(데이터길이 - index - 1): # 조건체크
		if 앞데이터 > 뒤데이터:
		 	swap(앞데이터, 뒤데이터)
```



실제 코드

```python
import random

def bubblesort(data):
    for index1 in range(len(data) - 1): # 턴
        swap = False
        for index2 in range(len(data) - index1 - 1): # 조건체크
            if data[index2] > data[index2 + 1]:
                data[index2], data[index2 + 1] = data[index2 + 1], data[index2]
                swap = True
        if swap == False: # 정렬 다 되었으면, 바뀔 게 더 없다면
            break
    return data

data_list = random.sample(range(100), 50)
print("정렬 전")
print(data_list)
print("정렬 후")
print(bubblesort(data_list))
```

```
[84, 3, 87, 1, 32, 16, 63, 54, 90, 24, 68, 99, 48, 36, 10, 25, 89, 92, 81, 76, 18, 37, 27, 43, 34, 57, 22, 40, 41, 4, 44, 59, 
77, 14, 19, 20, 31, 72, 56, 95, 39, 58, 15, 93, 33, 26, 97, 2, 69, 65]
[1, 2, 3, 4, 10, 14, 15, 16, 18, 19, 20, 22, 24, 25, 26, 27, 31, 32, 33, 34, 36, 37, 39, 40, 41, 43, 44, 48, 54, 56, 57, 58, 59, 63, 65, 68, 69, 72, 76, 77, 81, 84, 87, 89, 90, 92, 93, 95, 97, 99]
```



#### 3. 알고리즘 분석

- 반복문이 두 개 O(n^2)
  - 최악의 경우, n * (n - 1) / 2
- 완전 정렬이 되어 있는 경우라면 최선은 O(n)
  - swap 변수로 빠져나올 수 있음