#### 2-1 함수의 재귀적 호출의 이해



- **재귀함수**의 기본적인 이해



재귀함수 -> 함수 내에서 자기 자신을 다시 호출하는 함수를 의미한다.



```c
void Recursive(void){
printf("Recursive call! \n");
Recursive(); // 자신을 호출
}
```



그렇다면 위 형태의 함수호출은 어떻게 이해해야 할까? 

호출 Recursive();를 만나면 다시 void Recursive(void){}로 재진입을 하는 걸까?

완료되지 않은 함수를 다시 호출하는 것이 가능하다. Recursive 함수가 호출되면, Recursive 함수의 복사본이 만들어져 본사본이 실행되는 구조로 재귀함수의 호출이 진행된다. 

즉 원본 함수가 하나 있고, 재귀함수 호출을 하게 되면 원본 함수의 복사본 함수를 실행시킨다는 뜻이다.

실제로 함수를 구성하는 명령문은 CPU로 이동되어(복사되어) 실행된다. 그런데 이 명령문은 얼마든지 CPU로 이동이(복사가) 가능하기 때문에 Recursive 함수가 완료하지 않은 상태에서 다시 Recursive 함수 앞 부분에 위치한 명령문을 CPU로 이동시키는 것은 문제가 되지 않기 때문에 재귀적인 함수 호출이 가능한 것이다.



```c
#include <stdio.h>

void Recursive(int num){

    if(num <= 0){   // 재귀 탈출 조건
        return;     // 재귀 탈출
    }
    printf("Recursive call! %d \n", num);
    Recursive(num-1);
}

int main(void){
    Recursive(3);
    return 0;
}
```



마지막 호출에서 return 0;을 만나고 돌아가면서 반환을 하는 형식이다. 

이렇듯 재귀함수를 정의할 때 탈출조건을 구성하는 것은 매우 중요한 일이다.



- 재귀함수의 디자인 사례



재귀함수는 자료구조나 알고리즘의 어려운 문제를 단순화하는데 중요한 수단이다. 무엇보다 재귀함수가 있기 때문에 재귀적인 수학적 수식을 그대로 옮길 수 있다. 



예시로 팩토리얼의 재귀적 특성을 보자.

n! = n * (n-1) * (n-2) * ....... * 2 * 1

=> n * (n-1)!



정수 n팩토리얼은 정수 n과 n-1 팩토리얼의 곱으로 표현할 수 있으므로, n팩토리얼 f(n)은 다음과 같다.



f(n) -> n * f(n-1)  - n >= 1

​       -> 1 			   - n = 0 (0!은 1이므로)